homework-01
===========

#最大子数组和
##一维的情况

最朴素最暴力的方法是枚举所有的sum[i,j]，算出其值然后取最大，时间复杂度为O(N^3)。

注意到sum[i,j]=sum[i,j-1]+a[i,j]，所以不必每个sum[i,j]都重新算一遍，只需要通过前面的值来递推即可。时间复杂度降为O(N^2)

我们对所有的sum[i,j]来分类，用tail[j]表示所有的sum[i,j]的最大值，即tail[j]=max{sum[i,j]|1<=i<=j}，表示所有由a[j]结尾的子串中的最大的和。

那么我们的目标转化为求最大的tail，不过这样分析起来似乎没有任何的优化。

不过我们发现，假设tail[j-1]已经求出了，那么tail[j]只有取两种情况：

1. 以tail[j-1]和a[j]组成新的子串
2. 放弃tail[j-1]，重新由a[j]为一单独的新串。

因此我们得到如下状态转移方程：

tail[j]=max{tail[j-1]+a[j],a[j]}

求解问题只需从小到大遍历一遍O(N)的状态空间，每次转移需要O(1)时间复杂度，所以总共只有O(N)时间复杂度。

##二维的情况

在有了一维度的解答之后，我们很容易想到通过枚举上下界来把二维的问题转化为一维，需要枚举C(N,2)+N种上下界，每一种需要O(M)时间复杂度来计算，因此总共需要O(N^2*M)的时间复杂度。

##文件说明
一维情况的程序为one.c,测试输入为input1.txt,输出为output1.txt
二维情况的程序为two.c,测试输入为input2.txt,输出为output2.txt
